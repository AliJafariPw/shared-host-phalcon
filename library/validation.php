<?php


namespace Phalcon;

use Phalcon\Di\Injectable;
use Phalcon\ValidationInterface;
use Phalcon\Validation\Exception;
use Phalcon\Validation\Message\Group;
use Phalcon\Validation\MessageInterface;
use Phalcon\Validation\ValidatorInterface;
use Phalcon\Validation\CombinedFieldsValidator;


/***
 * Phalcon\Validation
 *
 * Allows to validate data using custom or built-in validators
 **/

class Validation extends Injectable {

    protected $_data;

    protected $_entity;

    protected $_validators;

    protected $_combinedFieldsValidators;

    protected $_filters;

    protected $_messages;

    protected $_defaultMessages;

    protected $_labels;

    protected $_values;

    /***
	 * Phalcon\Validation constructor
	 **/
    public function __construct($validators  = null ) {
		if ( count(validators) ) {
			$this->_validators = array_filter(validators, function(var element) {
				return gettype($element[0]) != "array" || !(element[1] instanceof CombinedFieldsValidator);
			});
			$this->_combinedFieldsValidators = array_filter(validators, function(var element) {
				return gettype($element[0]) == "array" && element[1] instanceof CombinedFieldsValidator;
			});
		}

		this->setDefaultMessages();

		/**
		 * Check for ( an 'initialize' method
		 */
		if ( method_exists(this, "initialize") ) {
			this->{"initialize"}();
		}
    }

    /***
	 * Validate a set of data according to a set of rules
	 *
	 * @param array|object data
	 * @param object entity
	 * @return \Phalcon\Validation\Message\Group
	 **/
    public function validate($data  = null , $entity  = null ) {

		$validators = $this->_validators;
		$combinedFieldsValidators = $this->_combinedFieldsValidators;

		if ( gettype($validators) != "array" ) {
			throw new Exception("There are no validators to validate");
		}

		/**
		 * Clear pre-calculated values
		 */
		$this->_values = null;

		/**
		 * Implicitly creates a Phalcon\Validation\Message\Group object
		 */
		$messages = new Group();

		if ( entity !== null ) {
			this->setEntity(entity);
		}

		/**
		 * Validation classes can implement the 'befor (eValidation' callback
		 */
		if ( method_exists(this, "befor (eValidation") ) ) {
			$status = $this->) {"befor (eValidation"}(data, entity, messages);
			if ( status === false ) {
				return status;
			}
		}

		$this->_messages = messages;

		if ( data !== null ) {
			if ( gettype($data) == "array" || gettype($data) == "object" ) {
				$this->_data = data;
			} else {
				throw new Exception("Invalid data to validate");
			}
		}

		foreach ( $validators as $scope ) {

			if ( gettype($scope) != "array" ) {
				throw new Exception("The validator scope is not valid");
			}

			$field = scope[0],
				validator = scope[1];

			if ( gettype($validator) != "object" ) {
				throw new Exception("One of the validators is not valid");
			}

			/**
			 * Call internal validations, if ( it returns true, then skip the current validator
			 */
			if ( $this->preChecking(field, validator) ) {
				continue;
			}

			/**
			 * Check if ( the validation must be canceled if ( this validator fails
			 */
			if ( validator->validate(this, field) === false ) {
				if ( validator->getOption("cancelOnFail") ) {
					break;
				}
			}
		}

		foreach ( $combinedFieldsValidators as $scope ) {
			if ( gettype($scope) != "array" ) {
				throw new Exception("The validator scope is not valid");
			}

			$field = scope[0],
				validator = scope[1];

			if ( gettype($validator) != "object" ) {
				throw new Exception("One of the validators is not valid");
			}

			/**
			 * Call internal validations, if ( it returns true, then skip the current validator
			 */
			if ( $this->preChecking(field, validator) ) {
				continue;
			}

			/**
			 * Check if ( the validation must be canceled if ( this validator fails
			 */
			if ( validator->validate(this, field) === false ) {
				if ( validator->getOption("cancelOnFail") ) {
					break;
				}
			}
		}

		/**
		 * Get the messages generated by the validators
		 */
		if ( method_exists(this, "afterValidation") ) {
			this->{"afterValidation"}(data, entity, $this->_messages);
		}

		return $this->_messages;
    }

    /***
	 * Adds a validator to a field
	 **/
    public function add($field , $validator ) {
		if ( gettype($field) == "array" ) {
			// Uniqueness validator for ( combination of fields is handled dif (ferently
			if ( validator instanceof CombinedFieldsValidator ) {
				$this->_combinedFieldsValidators[] = [field, validator];
			}
			else {
				foreach ( $field as $singleField ) {
					$this->_validators[] = [singleField, validator];
				}
			}
		}
		elseif ( gettype($field) == "string" ) {
			$this->_validators[] = [field, validator];
		}
		else {
			throw new Exception("Field must be passed as array of fields or string");
		}
		return this;
    }

    /***
	 * Alias of `add` method
	 **/
    public function rule($field , $validator ) {
		return $this->add(field, validator);
    }

    /***
	 * Adds the validators to a field
	 **/
    public function rules($field , $validators ) {

		foreach ( $validators as $validator ) {
			if ( validator instanceof ValidatorInterface ) {
				this->add(field, validator);
			}
		}

		return this;
    }

    /***
	 * Adds filters to the field
	 *
	 * @param string field
	 * @param array|string filters
	 * @return \Phalcon\Validation
	 **/
    public function setFilters($field , $filters ) {
		if ( gettype($field) == "array" ) {
			foreach ( $field as $singleField ) {
				$this->_filters[singleField] = filters;
			}
		}
		elseif ( gettype($field) == "string" ) {
			$this->_filters[field] = filters;
		}
		else {
			throw new Exception("Field must be passed as array of fields or string.");
		}
		return this;
    }

    /***
	 * Returns all the filters or a specific one
	 *
	 * @param string field
	 * @return mixed
	 **/
    public function getFilters($field  = null ) {
		$filters = $this->_filters;

		if ( field === null || field === "" ) {
			return filters;
		}

		if ( !fetch fieldFilters, filters[field] ) {
			return null;
		}

		return fieldFilters;
    }

    /***
	 * Returns the validators added to the validation
	 **/
    public function getValidators() {
		return $this->_validators;
    }

    /***
	 * Sets the bound entity
	 *
	 * @param object entity
	 **/
    public function setEntity($entity ) {
		if ( gettype($entity) != "object" ) {
			throw new Exception("Entity must be an object");
		}
		$this->_entity = entity;
    }

    /***
	 * Returns the bound entity
	 *
	 * @return object
	 **/
    public function getEntity() {
		return $this->_entity;
    }

    /***
	 * Adds default messages to validators
	 **/
    public function setDefaultMessages($messages ) {

		$defaultMessages = [
			"Alnum": "Field :field must contain only letters and numbers",
			"Alpha": "Field :field must contain only letters",
			"Between": "Field :field must be within the range of :min to :max",
			"Confirmation": "Field :field must be the same as :with",
			"Digit": "Field :field must be numeric",
			"Email": "Field :field must be an email address",
			"ExclusionIn": "Field :field must not be a part of list: :domain",
			"FileEmpty": "Field :field must not be empty",
			"FileIniSize": "File :field exceeds the maximum file size",
			"FileMaxResolution": "File :field must not exceed :max resolution",
			"FileMinResolution": "File :field must be at least :min resolution",
			"FileSize": "File :field exceeds the size of :max",
			"FileType": "File :field must be of type: :types",
			"FileValid": "Field :field is not valid",
			"Identical": "Field :field does not have the expected value",
			"InclusionIn": "Field :field must be a part of list: :domain",
			"Numericality": "Field :field does not have a valid numeric for (mat",
			"PresenceOf": "Field :field is required",
			"Regex": "Field :field does not match the required for (mat",
			"TooLong": "Field :field must not exceed :max characters long",
			"TooShort": "Field :field must be at least :min characters long",
			"Uniqueness": "Field :field must be unique",
			"Url": "Field :field must be a url",
			"CreditCard": "Field :field is not valid for ( a credit card number",
			"Date": "Field :field is not a valid date"
		];

		$this->_defaultMessages = array_merge(defaultMessages, messages);

		return $this->_defaultMessages;
    }

    /***
	 * Get default message for validator type
	 **/
    public function getDefaultMessage($type ) {

		if ( fetch defaultMessage, $this->_defaultMessages[type] ) {
			return defaultMessage;
		}

		return "";
    }

    /***
	 * Returns the registered validators
	 **/
    public function getMessages() {
		return $this->_messages;
    }

    /***
	 * Adds labels for fields
	 **/
    public function setLabels($labels ) {
		$this->_labels = labels;
    }

    /***
	 * Get label for field
	 *
	 * @param string field
	 * @return string
	 **/
    public function getLabel($field ) {

		$labels = $this->_labels;

		if ( gettype($field) == "array" ) {
			return join(", ", field);
		}

		if ( fetch value, labels[field] ) {
			return value;
		}

		return field;
    }

    /***
	 * Appends a message to the messages list
	 **/
    public function appendMessage($message ) {

		$messages = $this->_messages;
		if ( gettype($messages) != "object" ) {
			$messages = new Group();
		}

		messages->appendMessage(message);

		$this->_messages = messages;

		return this;
    }

    /***
	 * Assigns the data to an entity
	 * The entity is used to obtain the validation values
	 *
	 * @param object entity
	 * @param array|object data
	 * @return \Phalcon\Validation
	 **/
    public function bind($entity , $data ) {
		if ( gettype($entity) != "object" ) {
			throw new Exception("Entity must be an object");
		}

		if ( gettype($data) != "array" && gettype($data) != "object" ) {
			throw new Exception("Data to validate must be an array or object");
		}

		$this->_entity = entity,
			this->_data = data;

		return this;
    }

    /***
	 * Gets the a value to validate in the array/object data source
	 *
	 * @param string field
	 * @return mixed
	 **/
    public function getValue($field ) {
			filters, fieldFilters, dependencyInjector,
			filterService, camelizedField;

		$entity = $this->_entity;

		//  If the entity is an object use it to retrieve the values
		if ( gettype($entity) == "object" ) {
			$camelizedField = camelize(field);
			$method = "get" . camelizedField;
			if ( method_exists(entity, method) ) {
				$value = entity->{method}();
			} else {
				if ( method_exists(entity, "readAttribute") ) {
					$value = entity->readAttribute(field);
				} else {
					if ( isset entity->) {field} ) {
						$value = entity->{field};
					} else {
						$value = null;
					}
				}
			}
		}
		else {
			$data = $this->_data;

			if ( gettype($data) != "array" && gettype($data) != "object" ) {
				throw new Exception("There is no data to validate");
			}

			// Check if ( there is a calculated value
			$values = $this->_values;
			if ( fetch value, values[field] ) {
				return value;
			}

			$value = null;
			if ( gettype($data) == "array" ) {
				if ( isset($data[field]) ) {
					$value = data[field];
				}
			} else {
				if ( gettype($data) == "object" ) {
					if ( isset data->) {field} ) {
						$value = data->{field};
					}
				}
			}
		}

		if ( gettype($value) == "null" ) {
			return null;
		}

		$filters = $this->_filters;

		if ( fetch fieldFilters, filters[field] ) {

			if ( fieldFilters ) {

				$dependencyInjector = $this->getDI();
				if ( gettype($dependencyInjector) != "object" ) {
					$dependencyInjector = Di::getDefault();
					if ( gettype($dependencyInjector) != "object" ) {
						throw new Exception("A dependency injector is required to obtain the 'filter' service");
					}
				}

				$filterService = dependencyInjector->getShared("filter");
				if ( gettype($filterService) != "object" ) {
					throw new Exception("Returned 'filter' service is invalid");
				}

				$value = filterService->sanitize(value, fieldFilters);

				/**
				 * Set filtered value in entity
				 */
				if ( gettype($entity) == "object" ) {
					$method = "set" . camelizedField;
					if ( method_exists(entity, method) ) {
						entity->{method}(value);
					} else {
						if ( method_exists(entity, "writeAttribute") ) {
							entity->writeAttribute(field, value);
						} else {
							if ( property_exists(entity, field) ) {
								$entity->{field} = value;
							}
						}
					}
				}

				return value;
			}
		}

		// Cache the calculated value only if ( it's not entity
		if ( gettype($entity) != "object" ) {
			$this->_values[field] = value;
		}

		return value;
    }

    /***
	 * Internal validations, if it returns true, then skip the current validator
	 **/
    protected function preChecking($field , $validator ) {
		if ( gettype($field) == "array" ) {
			foreach ( $field as $singleField ) {
				$result = $this->preChecking(singleField, validator);
				if ( result ) {
					return result;
				}
			}
		}
		else {
			$allowEmpty = validator->getOption("allowEmpty", false);
			if ( allowEmpty ) {
				if ( method_exists(validator, "isAllowEmpty") ) {
					return validator->isAllowEmpty(this, field);
				}
				$value = $this->getValue(field);
				if ( gettype($allowEmpty) == "array" ) {
					foreach ( $allowEmpty as $emptyValue ) {
						if ( emptyValue === value ) {
							return true;
						}
					}
					return false;						
				}
				return empty value;
			}
		}

		return false;
    }

}